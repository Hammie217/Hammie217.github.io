library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity controller is
    Port ( clk,rst : in std_logic;
           start_button,stop_button : in std_logic;
           stopped,running,starting,stopping : out std_logic);
end controller;

architecture Behavioral of controller is

	-- Define an enumerated type for all the states in your state machine
 	type state_type is (st_stopped, st_starting, st_running, st_stopping); 
   
	-- Declare two signals one for the current state and one for the next state
	signal state, next_state : state_type; 


begin

	sequential_part: process (clk,rst)
   begin
      if rst='1' then
         state <= st_stopped;		-- define the initial state upon reset
      elsif rising_edge(clk) then
         state <= next_state;		-- update the state on the rising edge of the next clock cycle
      end if;
   end process;
 
   combinational_part: process (state, start_button, stop_button )  -- process sensitivity list includes current state and all state machine inputs
   begin
      next_state <= state;  --default is to stay in current state

		-- default values for all outputs (by convention the "do nothing" condition) - avoids unwanted latches
		stopped  <= '0';
		running  <= '0';
		starting <= '0';
		stopping <= '0';
		
		-- Use a large case statement to define the next_state for every current state
      case (state) is
         when st_stopped =>
						stopped <= '1';	
						if (start_button = '1') and (stop_button = '0') then
							next_state <= st_starting;
						end if;

			when st_starting =>
						starting <= '1';
						if (stop_button = '1') then
							next_state <= st_stopped;
						else
							next_state <= st_running;
						end if;

			when st_running =>
						running <= '1';
						if (stop_button = '1') then
							next_state <= st_stopping;
						end if;

			when st_stopping =>
						stopping <= '1';
						next_state <= st_stopped; -- unconditionally goes to next state

			when others =>
						next_state <= st_stopped; -- prevent an error causing the state machine sticking in an unused state
		end case;
	end process;	



end Behavioral;
